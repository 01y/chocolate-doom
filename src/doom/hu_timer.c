//
// Copyright(C) 1993-1996 Id Software, Inc.
// Copyright(C) 2005-2014 Simon Howard
// Copyright(C) 2018 Fabian Greffrath
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// DESCRIPTION:
//	CNDOOM timers
//	Adapted from cndoom-2.0.3.2/src/doom/cn_timer.c:1-273
//

#include "doomstat.h"
#include "i_system.h"
#include "i_video.h"
#include "m_misc.h"
#include "v_trans.h"

#include "r_main.h"

#define TFONTWIDTH 5
#define TFONTHEIGHT 6
#define TFONTCOLON 10
#define TFONTDOT 11
#define TFONTCHARS 12
#define INITIAL_CHARS 8
#define BORDER_H 2
#define BORDER_V 1

static int timer_x, timer_y, timer_w, timer_n = INITIAL_CHARS;
static const int timer_h = TFONTHEIGHT + 2 * BORDER_V;

static const byte tfont[TFONTWIDTH * TFONTHEIGHT * TFONTCHARS] =
{
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
};

#define timer_color	168
#define timer_shadow	0

static void HU_DrawTimerCharacter (int x, int y, char c)
{
    int i, j;
    byte *screen_p;
    const byte *char_p;

    if (c == ':')
	c = TFONTCOLON;
    else if (c == '.')
	c = TFONTDOT;
    else if (c >= '0' && c <= '9')
	c -= '0';
    else
	I_Error ("HU_DrawTimerCharacter: Bad character #%i.\n", c);

    screen_p = I_VideoBuffer + y * SCREENWIDTH + x;
    char_p = tfont + c * TFONTWIDTH;

    for (i = 0; i < TFONTHEIGHT; i++)
    {
	for (j = 0; j < TFONTWIDTH; j++)
	{
	    if (*char_p & 1)
		*screen_p++ = timer_color;
	    else
	    if (*char_p & 2)
		*screen_p++ = timer_shadow;
	    else
		screen_p++;

	    char_p++;
	}

	screen_p += SCREENWIDTH - TFONTWIDTH;
	char_p += TFONTWIDTH * (TFONTCHARS - 1);
    }

    return;
}

static void HU_DimBox ()
{
    int i, j;
    byte *screen_p;

    screen_p = I_VideoBuffer + timer_y * SCREENWIDTH + timer_x;

    for (i = 0; i < timer_h; i++)
    {
	for (j = 0; j < timer_w; j++)
	{
	    *screen_p = cr[CR_DARK][*screen_p];
	    screen_p++;
	}

	screen_p += SCREENWIDTH - timer_w;
    }
}

void HU_UpdateTimerLocation (const int window)
{
    if (window)
    {
	// align with view window
	timer_w = timer_n * TFONTWIDTH + 2 * BORDER_H;
	timer_x = viewwindowx + scaledviewwidth - timer_w;
	timer_y = viewwindowy;
    }
    else
    {
	// align with screen
	timer_w = timer_n * TFONTWIDTH + 2 * BORDER_H;
	timer_x = SCREENWIDTH - timer_w;
	timer_y = 0;
    }
}

void HU_DrawTimer (void)
{
    char buffer[16];
    int i, x;
    static int prev_n = INITIAL_CHARS;

    timer_n =
    M_snprintf(buffer, sizeof(buffer),
               "%02i:%02i.%02i",
               (leveltime / TICRATE) / 60,
               (leveltime / TICRATE) % 60,
               leveltime % TICRATE);

    if (timer_n != prev_n)
    {
	HU_UpdateTimerLocation(1);
	prev_n = timer_n;
    }

    HU_DimBox();

    x = timer_x + BORDER_H;

    for (i = 0; i < timer_n; i++)
    {
	HU_DrawTimerCharacter(x, timer_y + BORDER_V, buffer[i]);
	x += TFONTWIDTH;
    }
}
